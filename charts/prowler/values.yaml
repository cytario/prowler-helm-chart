# This is to override the chart name.
nameOverride: ""
fullnameOverride: ""

# External PostgreSQL and Valkey secrets are required
# Create secrets with the following keys before installing:
#
# PostgreSQL secret (prowler-postgres-secret):
#   POSTGRES_HOST
#   POSTGRES_PORT
#   POSTGRES_ADMIN_USER
#   POSTGRES_ADMIN_PASSWORD
#   POSTGRES_USER
#   POSTGRES_PASSWORD
#   POSTGRES_DB
#
# Valkey secret (prowler-valkey-secret):
#   VALKEY_HOST
#   VALKEY_PORT
#   VALKEY_DB
#   VALKEY_PASSWORD (optional)

# Shared storage configuration for scan outputs between API and Worker
# This volume is mounted at /tmp/prowler_api_output in both API and Worker pods
sharedStorage:
  # Type of storage: emptyDir or persistentVolumeClaim
  # emptyDir: Data is lost when pods are deleted (suitable for development)
  # persistentVolumeClaim: Data persists across pod restarts (recommended for production)
  type: emptyDir
  # Configuration for emptyDir type
  emptyDir:
    # Medium can be "" (default, uses node's default storage) or "Memory" (tmpfs, faster but uses RAM)
    medium: ""
    # Size limit for emptyDir (e.g., "1Gi", "500Mi")
    sizeLimit: ""
  # Configuration for persistentVolumeClaim type
  persistentVolumeClaim:
    # Create a new PVC or use an existing one
    create: true
    # Name of existing PVC (only used if create: false)
    existingClaim: ""
    # Storage class name (leave empty to use default)
    storageClassName: ""
    # For API and Worker to share, use ReadWriteMany if available
    # Changing to other will fail
    accessMode: ReadWriteMany
    # Storage size
    size: 10Gi

ui:
  # This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
  replicaCount: 2

  # Pod Disruption Budget - ensures high availability during voluntary disruptions
  # More info: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
    # maxUnavailable: 1

  # This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
  image:
    repository: prowlercloud/prowler-ui
    # This sets the pull policy for images.
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: ""

  # This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  imagePullSecrets: []

  # This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Automatically mount a ServiceAccount's API credentials?
    automount: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  # This is for setting Kubernetes Annotations to a Pod.
  # For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  podAnnotations: {}
  # This is for setting Kubernetes Labels to a Pod.
  # For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  podLabels: {}

  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  securityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: false  # UI needs write access to /app/.next for Next.js
    runAsNonRoot: true
    runAsUser: 1000
    capabilities:
      drop:
        - ALL

  # This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
  service:
    # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    # This sets the ports more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
    port: 3000

  # This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
  ingress:
    enabled: false
    className: ""
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths:
          - path: /
            pathType: ImplementationSpecific
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources:
    limits:
      cpu: 1000m
      memory: 1Gi
    requests:
      cpu: 250m
      memory: 256Mi
  # This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
  livenessProbe:
    httpGet:
      path: /
      port: http
  readinessProbe:
    httpGet:
      path: /
      port: http

  # This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  # Additional volumes on the output Deployment definition.
  volumes: []
  # - name: foo
  #   secret:
  #     secretName: mysecret
  #     optional: false

  # Additional volumeMounts on the output Deployment definition.
  volumeMounts: []
  # - name: foo
  #   mountPath: "/etc/foo"
  #   readOnly: true

  nodeSelector: {}

  tolerations: []

  affinity: {}

api:
  # This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
  replicaCount: 2

  # Pod Disruption Budget - ensures high availability during voluntary disruptions
  # More info: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
    # maxUnavailable: 1

  # This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
  image:
    repository: prowlercloud/prowler-api
    # This sets the pull policy for images.
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: ""

  # Network policy configuration
  networkPolicy:
    enabled: false
    # Additional ingress rules
    ingress: []
    # Additional egress rules
    egress: []

  # RBAC configuration for Kubernetes scanning
  rbac:
    # Create ClusterRole and ClusterRoleBinding for Kubernetes resource scanning
    # Set to false if you don't plan to scan Kubernetes resources
    create: true
    # Additional RBAC rules to append
    rules: []

  # Shared with celery-worker and celery-beat
  djangoConfig:
    # API scan settings
    # The path to the directory where scan output should be stored
    DJANGO_TMP_OUTPUT_DIRECTORY: "/tmp/prowler_api_output"
    # The maximum number of findings to process in a single batch
    DJANGO_FINDINGS_BATCH_SIZE: "1000"
    # The maximum number of items to delete in a single batch operation
    DJANGO_DELETION_BATCH_SIZE: "1000"
    # Django settings
    DJANGO_ALLOWED_HOSTS: "*"
    DJANGO_BIND_ADDRESS: "0.0.0.0"
    DJANGO_PORT: "8080"
    DJANGO_DEBUG: "False"
    DJANGO_SETTINGS_MODULE: "config.django.production"
    # Select one of [ndjson|human_readable]
    DJANGO_LOGGING_FORMATTER: "ndjson"
    # Select one of [DEBUG|INFO|WARNING|ERROR|CRITICAL]
    # Applies to both Django and Celery Workers
    DJANGO_LOGGING_LEVEL: "INFO"
    # Defaults to the maximum available based on CPU cores if not set.
    DJANGO_WORKERS: "4"
    # Token lifetime is in minutes
    DJANGO_ACCESS_TOKEN_LIFETIME: "30"
    # Token lifetime is in minutes
    DJANGO_REFRESH_TOKEN_LIFETIME: "1440"
    # Throttle limit for token obtain endpoint (requests per hour)
    DJANGO_THROTTLE_TOKEN_OBTAIN: "10/hour"
    DJANGO_CACHE_MAX_AGE: "3600"
    DJANGO_STALE_WHILE_REVALIDATE: "60"
    DJANGO_MANAGE_DB_PARTITIONS: "True"
    DJANGO_BROKER_VISIBILITY_TIMEOUT: "86400"
    # Maximum number of celery deadlock detection attempts
    DJANGO_CELERY_DEADLOCK_ATTEMPTS: "5"
    # Optional Sentry configuration for error tracking
    # DJANGO_SENTRY_DSN: ""
    # SENTRY_ENVIRONMENT: "production"
    # SENTRY_RELEASE: ""
    # Optional OAuth configuration - Google
    # GOOGLE_OAUTH_CLIENT_ID: ""
    # GOOGLE_OAUTH_CLIENT_SECRET: ""
    # GOOGLE_OAUTH_CALLBACK_URL: ""
    # Optional OAuth configuration - GitHub
    # GITHUB_OAUTH_CLIENT_ID: ""
    # GITHUB_OAUTH_CLIENT_SECRET: ""
    # GITHUB_OAUTH_CALLBACK_URL: ""
  djangoConfigKeys:
    # Create secret with Django Keys using template-based generation
    # Keys are automatically generated using secure random values with Helm lookup for persistence
    # If false, you must manually create the secret
    # For production, consider generating keys manually:
    # - DJANGO_TOKEN_SIGNING_KEY - obtain from `openssl genrsa -out private.pem 2048`
    # - DJANGO_TOKEN_VERIFYING_KEY - obtain from `openssl rsa -in private.pem -pubout -out public.pem`
    # - DJANGO_SECRETS_ENCRYPTION_KEY - obtain from `openssl rand -base64 32`
    create: true

  # Secret names to be used as env vars.
  secrets: []
    # - "prowler-api-keys"

  command:
    - /home/prowler/docker-entrypoint.sh
  args:
    - prod

  # This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  imagePullSecrets: []

  # This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Automatically mount a ServiceAccount's API credentials?
    automount: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  # This is for setting Kubernetes Annotations to a Pod.
  # For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  podAnnotations: {}
  # This is for setting Kubernetes Labels to a Pod.
  # For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  podLabels: {}

  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  securityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: false  # API needs write access to DJANGO_TMP_OUTPUT_DIRECTORY
    runAsNonRoot: true
    runAsUser: 1000
    capabilities:
      drop:
        - ALL

  # This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
  service:
    # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    type: ClusterIP
    # This sets the ports more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
    port: 8080

  # This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
  ingress:
    enabled: false
    className: ""
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts:
      - host: chart-example.local
        paths:
          - path: /
            pathType: ImplementationSpecific
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  resources:
    limits:
      cpu: 2000m
      memory: 2Gi
    requests:
      cpu: 500m
      memory: 512Mi
  # This is to setup the startup, liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
  # Startup probe is useful for slow starting containers (DB migrations can take 3-4 minutes)
  startupProbe:
    httpGet:
      path: /api/v1/docs
      port: http
    failureThreshold: 30
    periodSeconds: 10
    # Total startup time: 30 * 10s = 5 minutes
  livenessProbe:
    failureThreshold: 10
    httpGet:
      path: /api/v1/docs
      port: http
    periodSeconds: 20
  readinessProbe:
    failureThreshold: 10
    httpGet:
      path: /api/v1/docs
      port: http
    periodSeconds: 20

  # This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  # Optional persistent storage for API configuration directory
  # This stores Prowler API configuration files at /home/prowler/.config/prowler-api
  configStorage:
    enabled: false
    # Type: emptyDir or persistentVolumeClaim
    type: persistentVolumeClaim
    # Configuration for emptyDir type
    emptyDir:
      medium: ""
      sizeLimit: ""
    # Configuration for persistentVolumeClaim type
    persistentVolumeClaim:
      create: true
      existingClaim: ""
      storageClassName: ""
      accessMode: ReadWriteOnce
      size: 1Gi

  # Additional volumes on the output Deployment definition.
  volumes: []
  # - name: foo
  #   secret:
  #     secretName: mysecret
  #     optional: false

  # Additional volumeMounts on the output Deployment definition.
  volumeMounts: []
  # - name: foo
  #   mountPath: "/etc/foo"
  #   readOnly: true

  nodeSelector: {}

  tolerations: []

  affinity: {}

worker:
  # This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
  replicaCount: 2

  # Pod Disruption Budget - ensures high availability during voluntary disruptions
  # More info: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
    # maxUnavailable: 1

  # This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
  image:
    repository: prowlercloud/prowler-api
    # This sets the pull policy for images.
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: ""

  command:
    - /home/prowler/docker-entrypoint.sh
  args:
    - worker

  # This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  imagePullSecrets: []

  # This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Automatically mount a ServiceAccount's API credentials?
    automount: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  # This is for setting Kubernetes Annotations to a Pod.
  # For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  podAnnotations: {}
  # This is for setting Kubernetes Labels to a Pod.
  # For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  podLabels: {}

  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  securityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: false  # Worker needs write access for scan outputs
    runAsNonRoot: true
    runAsUser: 1000
    capabilities:
      drop:
        - ALL

  resources:
    limits:
      cpu: 2000m
      memory: 2Gi
    requests:
      cpu: 500m
      memory: 512Mi
  # This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
  livenessProbe: {}
  readinessProbe: {}

  # This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 10
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  # Additional volumes on the output Deployment definition.
  volumes: []
  # - name: foo
  #   secret:
  #     secretName: mysecret
  #     optional: false

  # Additional volumeMounts on the output Deployment definition.
  volumeMounts: []
  # - name: foo
  #   mountPath: "/etc/foo"
  #   readOnly: true

  nodeSelector: {}

  tolerations: []

  affinity: {}

worker_beat:
  # This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
  replicaCount: 1

  # Pod Disruption Budget - for beat worker, we ensure at least 0 are available
  # (since only 1 should run at a time, but we want controlled disruption)
  # More info: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
  podDisruptionBudget:
    enabled: false
    minAvailable: 0
    # maxUnavailable: 1

  # This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
  image:
    repository: prowlercloud/prowler-api
    # This sets the pull policy for images.
    pullPolicy: IfNotPresent
    # Overrides the image tag whose default is the chart appVersion.
    tag: ""

  command:
    - /home/prowler/docker-entrypoint.sh
  args:
    - beat

  # This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  imagePullSecrets: []

  # This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Automatically mount a ServiceAccount's API credentials?
    automount: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  # This is for setting Kubernetes Annotations to a Pod.
  # For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  podAnnotations: {}
  # This is for setting Kubernetes Labels to a Pod.
  # For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  podLabels: {}

  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  securityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: false  # Beat worker needs write access for scheduling state
    runAsNonRoot: true
    runAsUser: 1000
    capabilities:
      drop:
        - ALL

  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 100m
      memory: 128Mi
  # This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
  livenessProbe: {}
  readinessProbe: {}

  # This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 10
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

  # Additional volumes on the output Deployment definition.
  volumes: []
  # - name: foo
  #   secret:
  #     secretName: mysecret
  #     optional: false

  # Additional volumeMounts on the output Deployment definition.
  volumeMounts: []
  # - name: foo
  #   mountPath: "/etc/foo"
  #   readOnly: true

  nodeSelector: {}

  tolerations: []

  affinity: {}

# Neo4j (DozerDB) configuration for Attack Paths feature (Prowler 5.17+)
# DozerDB is a Neo4j-compatible database optimized for Prowler
neo4j:
  # Enable/disable Neo4j deployment
  # Required for Prowler 5.17+ Attack Paths feature
  enabled: true

  # Container image configuration
  image:
    repository: graphstack/dozerdb
    tag: "5.26.3.0"
    pullPolicy: IfNotPresent

  # Authentication configuration
  auth:
    username: neo4j
    # Password is auto-generated if not provided
    # To set your own: --set neo4j.auth.password=yourpassword
    # Auto-generated password is preserved across upgrades
    password: ""

  # Neo4j/DozerDB configuration
  config:
    # Maximum number of databases (for multi-tenant support)
    maxDatabases: 1000
    # Page cache size for performance
    pagecacheSize: "1G"
    # Initial JVM heap size
    heapInitialSize: "1G"
    # Maximum JVM heap size
    heapMaxSize: "1G"

  # Service configuration
  service:
    type: ClusterIP
    # Bolt protocol port (used by Prowler)
    port: 7687
    # HTTP port (for Neo4j Browser, optional)
    httpPort: 7474

  # Persistence configuration
  persistence:
    # Enable persistent storage for Neo4j data
    # Enabled by default for data durability
    enabled: true
    # Storage size
    size: 10Gi
    # Storage class (leave empty for default)
    storageClass: ""
    # Access mode
    accessMode: ReadWriteOnce

  # Resource requests and limits
  resources:
    requests:
      memory: "2Gi"
      cpu: "500m"
    limits:
      memory: "4Gi"
      cpu: "2000m"

  # Pod security context
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 7474
    fsGroup: 7474
    seccompProfile:
      type: RuntimeDefault

  # Container security context
  securityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: false  # Neo4j needs write access to data directory
    runAsNonRoot: true
    runAsUser: 7474
    capabilities:
      drop:
        - ALL

  # This is for the secrets for pulling an image from a private repository
  imagePullSecrets: []

  # Pod annotations
  podAnnotations: {}

  # Pod labels
  podLabels: {}

  # Node selector
  nodeSelector: {}

  # Tolerations
  tolerations: []

  # Affinity rules
  affinity: {}
