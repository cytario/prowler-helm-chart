{{- if .Values.api.djangoConfigKeys.create -}}
{{- $secretName := printf "%s-api-django-config-keys" (include "prowler.fullname" .) -}}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "prowler.fullname" . }}-generate-django-keys
  labels:
    {{- include "prowler.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  backoffLimit: 3
  template:
    metadata:
      name: {{ include "prowler.fullname" . }}-generate-django-keys
    spec:
      restartPolicy: Never
      {{- with .Values.api.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      serviceAccountName: {{ include "prowler.fullname" . }}-key-generator
      automountServiceAccountToken: true
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 1000
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: generate-keys
        image: {{ include "prowler.image" (dict "imageConfig" .Values.api.image "defaultTag" .Chart.AppVersion) | quote }}
        imagePullPolicy: {{ .Values.api.image.pullPolicy }}
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1000
          capabilities:
            drop:
            - ALL
        command:
        - python
        - -c
        - |
          import os, sys, base64
          from cryptography.hazmat.primitives.asymmetric import rsa
          from cryptography.hazmat.primitives import serialization
          from cryptography.hazmat.backends import default_backend

          SECRET_NAME = {{ $secretName | quote }}
          NAMESPACE = {{ .Release.Namespace | quote }}

          # Try kubernetes Python client first, fall back to subprocess+kubectl
          try:
              from kubernetes import client, config
              config.load_incluster_config()
              v1 = client.CoreV1Api()
              USE_K8S_CLIENT = True
          except ImportError:
              import subprocess
              USE_K8S_CLIENT = False

          # Check if secret already exists
          print("Checking if Django keys secret already exists...")
          if USE_K8S_CLIENT:
              try:
                  v1.read_namespaced_secret(SECRET_NAME, NAMESPACE)
                  print("Secret already exists. Skipping key generation.")
                  sys.exit(0)
              except client.exceptions.ApiException as e:
                  if e.status != 404:
                      raise
          else:
              result = subprocess.run(
                  ["kubectl", "get", "secret", SECRET_NAME, "-n", NAMESPACE],
                  capture_output=True,
              )
              if result.returncode == 0:
                  print("Secret already exists. Skipping key generation.")
                  sys.exit(0)

          print("Generating new Django keys...")

          # Generate RSA key pair for JWT signing
          private_key = rsa.generate_private_key(
              public_exponent=65537,
              key_size=2048,
              backend=default_backend(),
          )
          private_pem = private_key.private_bytes(
              encoding=serialization.Encoding.PEM,
              format=serialization.PrivateFormat.TraditionalOpenSSL,
              encryption_algorithm=serialization.NoEncryption(),
          ).decode("utf-8")
          public_pem = private_key.public_key().public_bytes(
              encoding=serialization.Encoding.PEM,
              format=serialization.PublicFormat.SubjectPublicKeyInfo,
          ).decode("utf-8")

          # Generate Fernet encryption key (32 bytes base64 encoded)
          encryption_key = base64.b64encode(os.urandom(32)).decode("utf-8")

          # Create the Kubernetes secret
          if USE_K8S_CLIENT:
              secret = client.V1Secret(
                  metadata=client.V1ObjectMeta(name=SECRET_NAME),
                  string_data={
                      "DJANGO_TOKEN_SIGNING_KEY": private_pem,
                      "DJANGO_TOKEN_VERIFYING_KEY": public_pem,
                      "DJANGO_SECRETS_ENCRYPTION_KEY": encryption_key,
                  },
              )
              v1.create_namespaced_secret(NAMESPACE, secret)
          else:
              subprocess.run(
                  [
                      "kubectl", "create", "secret", "generic", SECRET_NAME,
                      "-n", NAMESPACE,
                      "--from-literal=DJANGO_TOKEN_SIGNING_KEY=" + private_pem,
                      "--from-literal=DJANGO_TOKEN_VERIFYING_KEY=" + public_pem,
                      "--from-literal=DJANGO_SECRETS_ENCRYPTION_KEY=" + encryption_key,
                  ],
                  check=True,
              )

          print("Django keys generated and secret created successfully.")
        volumeMounts:
        - name: tmp
          mountPath: /tmp
      volumes:
      - name: tmp
        emptyDir: {}
{{- end -}}
