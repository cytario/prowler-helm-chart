{{- if .Values.api.djangoConfigKeys.create -}}
{{- $secretName := printf "%s-api-django-config-keys" (include "prowler.fullname" .) -}}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "prowler.fullname" . }}-generate-django-keys
  labels:
    {{- include "prowler.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  backoffLimit: 3
  template:
    metadata:
      name: {{ include "prowler.fullname" . }}-generate-django-keys
    spec:
      restartPolicy: Never
      {{- with .Values.api.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      serviceAccountName: {{ include "prowler.fullname" . }}-key-generator
      automountServiceAccountToken: true
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 1000
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: generate-keys
        image: {{ include "prowler.image" (dict "imageConfig" .Values.api.image "defaultTag" .Chart.AppVersion) | quote }}
        imagePullPolicy: {{ .Values.api.image.pullPolicy }}
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1000
          capabilities:
            drop:
            - ALL
        command:
        - python
        - -c
        - |
          import base64, json, os, ssl, sys
          import urllib.request
          from cryptography.hazmat.primitives.asymmetric import rsa
          from cryptography.hazmat.primitives import serialization

          SECRET_NAME = {{ $secretName | quote }}
          NAMESPACE = {{ .Release.Namespace | quote }}

          # K8s API via in-cluster service account token (no kubectl or k8s client needed)
          API_HOST = os.environ.get("KUBERNETES_SERVICE_HOST", "kubernetes.default.svc")
          API_PORT = os.environ.get("KUBERNETES_SERVICE_PORT", "443")
          API_BASE = f"https://{API_HOST}:{API_PORT}"
          TOKEN_PATH = "/var/run/secrets/kubernetes.io/serviceaccount/token"
          CA_PATH = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"

          with open(TOKEN_PATH) as f:
              token = f.read().strip()
          headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
          ctx = ssl.create_default_context(cafile=CA_PATH)

          def k8s_request(method, path, data=None):
              body = json.dumps(data).encode() if data else None
              req = urllib.request.Request(f"{API_BASE}{path}", data=body, headers=headers, method=method)
              try:
                  with urllib.request.urlopen(req, context=ctx) as resp:
                      return resp.status, json.loads(resp.read())
              except urllib.error.HTTPError as e:
                  return e.code, json.loads(e.read())

          # Check if secret already exists
          print("Checking if Django keys secret already exists...")
          status, _ = k8s_request("GET", f"/api/v1/namespaces/{NAMESPACE}/secrets/{SECRET_NAME}")
          if status == 200:
              print("Secret already exists. Skipping key generation.")
              sys.exit(0)
          if status != 404:
              print(f"Unexpected API response: {status}")
              sys.exit(1)

          print("Generating new Django keys...")

          # Generate RSA key pair for JWT signing
          private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
          private_pem = private_key.private_bytes(
              encoding=serialization.Encoding.PEM,
              format=serialization.PrivateFormat.TraditionalOpenSSL,
              encryption_algorithm=serialization.NoEncryption(),
          ).decode()
          public_pem = private_key.public_key().public_bytes(
              encoding=serialization.Encoding.PEM,
              format=serialization.PublicFormat.SubjectPublicKeyInfo,
          ).decode()

          # Generate Fernet encryption key (32 bytes base64 encoded)
          encryption_key = base64.b64encode(os.urandom(32)).decode()

          # Create the Kubernetes secret via API
          secret = {
              "apiVersion": "v1",
              "kind": "Secret",
              "metadata": {"name": SECRET_NAME},
              "stringData": {
                  "DJANGO_TOKEN_SIGNING_KEY": private_pem,
                  "DJANGO_TOKEN_VERIFYING_KEY": public_pem,
                  "DJANGO_SECRETS_ENCRYPTION_KEY": encryption_key,
              },
          }
          status, resp = k8s_request("POST", f"/api/v1/namespaces/{NAMESPACE}/secrets", secret)
          if status not in (200, 201):
              print(f"Failed to create secret: {status} {resp.get('message', '')}")
              sys.exit(1)

          print("Django keys generated and secret created successfully.")
        volumeMounts:
        - name: tmp
          mountPath: /tmp
      volumes:
      - name: tmp
        emptyDir: {}
{{- end -}}
